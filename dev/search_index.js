var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = ScenTrees2","category":"page"},{"location":"#ScenTrees2","page":"Home","title":"ScenTrees2","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for ScenTrees2.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [ScenTrees2]","category":"page"},{"location":"#RecipesBase.plot","page":"Home","title":"RecipesBase.plot","text":"plot(lt::Lattice,title = nothing, label=nothing)\n\nReturns a plot of a scenario lattice.\n\nArguments\n\nlt - A scenario lattice.\ntitle - A title for the plot.\nsimple - if simple is true, then unreachable paths are dropped, see details below.\nlabel - optional labels with LaTeX support. \n\nValue\n\n- returns the plot as a gr() figure.\n\nDetails:\n\nif simple is equal to true then states valued at 0.0 and have 0.0 probability to be reached are not plotted. \nTo make use of this feature the `check_tree()` routine should be used before (SLOW!)\n\nThere might connections with zero probability –> these shouldn't be plotted! TODO\n\n\n\n\n\n","category":"function"},{"location":"#RecipesBase.plot!-Union{Tuple{Tree{A, B, C, D}}, Tuple{D}, Tuple{C}, Tuple{B}, Tuple{A}, Tuple{Tree{A, B, C, D}, Any}, Tuple{Tree{A, B, C, D}, Any, Any}, Tuple{Tree{A, B, C, D}, Any, Any, Any}, Tuple{Tree{A, B, C, D}, Vararg{Any, 4}}} where {A, B, C, D}","page":"Home","title":"RecipesBase.plot!","text":"plot!(trr::Tree,title=nothing, simple = false, label=nothing)\n\nAdds an additional tree plot to an existing plot using plot!(). See tree_plot() for details.\n\n\n\n\n\n","category":"method"},{"location":"#RecipesBase.plot-Union{Tuple{Tree{A, B, C, D}}, Tuple{D}, Tuple{C}, Tuple{B}, Tuple{A}, Tuple{Tree{A, B, C, D}, Any}, Tuple{Tree{A, B, C, D}, Any, Any}, Tuple{Tree{A, B, C, D}, Any, Any, Any}} where {A, B, C, D}","page":"Home","title":"RecipesBase.plot","text":"plot(trr::Tree,title=nothing, simple = false, label=nothing)\n\nReturns the plot of the input tree trr.\n\nArguments\n\ntrr - A scenario tree.\ntitle - A title for the plot.\nsimple - if simple is true, then unreachable paths are dropped, see details below.\nlabel - optional labels with LaTeX support. \n\nValue\n\n- returns the plot as a gr() figure.\n\nDetails:\n\nif simple is equal to true then states valued at 0.0 and have 0.0 probability to be reached are not plotted. \nTo make use of this feature the `check_tree()` routine should be used before (SLOW!)\n\n\n\n\n\n","category":"method"},{"location":"#ScenTrees2.Wasserstein","page":"Home","title":"ScenTrees2.Wasserstein","text":"Wasserstein(p1::Vector{Float64}, p2::Vector{Float64}, distMatrix::Array{Float64,2}, r::Float64=1.)\n\nCalculates the Wasserstein with marginal distributions p1 and p2 for the distance matrix `distMatrix. \n\nOptionally the Hölder norm can be specified. The distance together with the optimal transport density is outputted. \n\n\n\n\n\n","category":"function"},{"location":"#ScenTrees2.build_probabilities!-Union{Tuple{D}, Tuple{C}, Tuple{B}, Tuple{A}, Tuple{Tree{A, B, C, D}, Matrix{Float64}}} where {A, B, C, D}","page":"Home","title":"ScenTrees2.build_probabilities!","text":"build_probabilities!(trr::Tree,probabilities::Array{Float64,2})\n\nReturns the probabilities of the nodes without probabilities if the array of probabilities is less than the length of parents in the stochastic approximation procedure.\n\n\n\n\n\n","category":"method"},{"location":"#ScenTrees2.checkTree-Union{Tuple{D}, Tuple{C}, Tuple{B}, Tuple{A}, Tuple{Tree{A, B, C, D}, Any}} where {A, B, C, D}","page":"Home","title":"ScenTrees2.checkTree","text":"checkTree(tree0::Tree{A,B,C,D}, eps) where {A,B,C,D}\n\nTransitions with zero probability are given positive probability eps such that conditional probabilities sum up to 1.0.\n\nThe correct adjustment can only be justified for each individual tree. Be careful in using this function as it can drastically alter the tree process described by tree0.\n\n\n\n\n\n","category":"method"},{"location":"#ScenTrees2.cumulProb!-Union{Tuple{Tree{A, B, C, D}}, Tuple{D}, Tuple{C}, Tuple{B}, Tuple{A}} where {A, B, C, D}","page":"Home","title":"ScenTrees2.cumulProb!","text":"cumulProb!(trr::Tree{A,B,C,D}) where {A,B,C,D}\n\nmodifies the probability vector of trr to show cumulative probabilities instead of conditional ones.\n\n\n\n\n\n","category":"method"},{"location":"#ScenTrees2.distFunction-Tuple{Vector{Float64}, Vector{Float64}}","page":"Home","title":"ScenTrees2.distFunction","text":"distFunction(states1::Vector{Float64}, states2::Vector{Float64})::Array{Float64,2}\n\nCalculates the distance abs(x-y) between all points of states1 and states2. \n\n\n\n\n\n","category":"method"},{"location":"#ScenTrees2.gaussian_path","page":"Home","title":"ScenTrees2.gaussian_path","text":"gaussian_path(n::Int64 = 4)\n\nReturns a 'nx1' dimensional array of Gaussian random walk.\n\n\n\n\n\n","category":"function"},{"location":"#ScenTrees2.height-Union{Tuple{Tree{A, B, C, D}}, Tuple{D}, Tuple{C}, Tuple{B}, Tuple{A}} where {A, B, C, D}","page":"Home","title":"ScenTrees2.height","text":"height(trr::Tree)\n\nReturns the height of the tree trr which is just the maximum number of the stages of each node.\n\n\n\n\n\n","category":"method"},{"location":"#ScenTrees2.kernel_scenarios","page":"Home","title":"ScenTrees2.kernel_scenarios","text":"kernel_scenarios(data::Union{Array{Int64,2},Array{Float64,2}}, kernelDistribution = Logistic; Markovian::Bool = true)\n\nReturns an instance of a closure of the conditional density estimation method.\n\nArgs:\n\ndata - a matrix of data in 2 dimension (NxT) where N is the number of trajectories and T is the number of stages.\nkernelDistribution - the distribution of the kernel functions. Default is Logistic distribution.\n\nAn optional keyword Markovian is passed to handle weights for Markovian trajectories or non-Markovian ones.\n\nTo get a Markov trajectory from above, KernelScenarios(data,kernelDistribution;Markovian=true)() gives the result for Markovian samples, which is used to generate a scenario lattice.\n\n\n\n\n\n","category":"function"},{"location":"#ScenTrees2.lattice_approximation","page":"Home","title":"ScenTrees2.lattice_approximation","text":"lattice_approximation(bstructure::Array{Int64,1}, path::Function, nIterations::Int64, r::Int64 = 2, dim::Int64 = 1)\n\nReturns a valuated approximated lattice for the stochastic process provided in any dimension. The default dimension is dim = 1 for a lattice in 1 dimension.\n\nArgs:\n\nbstructure - Branching structure of the scenario lattice e.g., bstructure = [1,2,3,4,5] represents a 5-staged lattice\npath - Function generating samples from a known distribution with length equal to the length of bstructure of the lattice.\nnIterations - Number of iterations to be performed.\nr - Parameter for the transportation distance.\ndim - dimension of the lattice to be generated. This depends entirely on the dimension of the samples generated.\n\n\n\n\n\n","category":"function"},{"location":"#ScenTrees2.leaves-Union{Tuple{Tree{A, B, C, D}}, Tuple{D}, Tuple{C}, Tuple{B}, Tuple{A}, Tuple{Tree{A, B, C, D}, Any}} where {A, B, C, D}","page":"Home","title":"ScenTrees2.leaves","text":"leaves(trr::Tree,node=Int64[])\n\nReturns the leaf nodes, their indexes and the conditional probabilities based on parent node.\n\nArguments:\n\ntrr - an instance of a Tree.\nnode - a node for which all leaf nodes are found.\n\nValues\n\nleaves - a vector of leaf nodes.\nomegas - a vector of indizes indicating the order of the elements in leaves.\nprob - the conditional probability of each leaf node conditional on node.\n\nIf node is not given, then node is treated as the root node. \n\n\n\n\n\n","category":"method"},{"location":"#ScenTrees2.nestedWasserstein","page":"Home","title":"ScenTrees2.nestedWasserstein","text":"nestedWasserstein(trr1,trr2,r=2)\n\nCalculates the nested distance based on the Wasserstein distance for two trees trr1 and trr2 Optionally the Hölder norm r can be specified.  \n\n\n\n\n\n","category":"function"},{"location":"#ScenTrees2.nodes-Union{Tuple{Tree{A, B, C, D}}, Tuple{D}, Tuple{C}, Tuple{B}, Tuple{A}, Tuple{Tree{A, B, C, D}, Any}} where {A, B, C, D}","page":"Home","title":"ScenTrees2.nodes","text":"nodes(trr::Tree,t=Int64[])\n\nReturns the nodes in the tree trr at stage t.\n\nExample:\n\njulia> trr = Tree(404);\njulia> nodes(trr,1)\n2-element Vector{Int64}:\n 2\n 3\n\n\n\n\n\n","category":"method"},{"location":"#ScenTrees2.part_lattice","page":"Home","title":"ScenTrees2.part_lattice","text":"part_lattice(lat, hist=nothing)\n\nProvides a subtree given an observed history hist. If no history is provided the lattice is returned.\n\nExample\n\nlat = Lattice(304);\nhist = [1 2]\npart_lattice(lat, hist)\n\n\n\n\n\n","category":"function"},{"location":"#ScenTrees2.part_tree","page":"Home","title":"ScenTrees2.part_tree","text":"part_tree(trr::Tree,node)\n\nReturns a reduced tree starting at node. If node is the root node then original tree is returned. \n\nArguments:\n\ntrr - an instance of Tree\nnode - a node of trr which becomes the new root node.\n\n\n\n\n\n","category":"function"},{"location":"#ScenTrees2.plot_path!-Tuple{Any}","page":"Home","title":"ScenTrees2.plot_path!","text":"plot_path!(path)\n\nPlots a given vector path on top of the tree/lattice\n\n\n\n\n\n","category":"method"},{"location":"#ScenTrees2.root-Union{Tuple{Tree{A, B, C, D}}, Tuple{D}, Tuple{C}, Tuple{B}, Tuple{A}, Tuple{Tree{A, B, C, D}, Any}} where {A, B, C, D}","page":"Home","title":"ScenTrees2.root","text":"root(trr::Tree,nodes=Int64[])\n\nReturns the root of the tree if the node is not specified.\n\n#Arguments:\n\ntrr - an instance of Tree.\nnodes - target node from root.\n\nIf nodes is not specified, it returns the root of the tree.\n\nIf nodes is specified, it returns a sequence of nodes from the root to the specified node.\n\n\n\n\n\n","category":"method"},{"location":"#ScenTrees2.running_maximum","page":"Home","title":"ScenTrees2.running_maximum","text":"running_maximum(n::Int64 = 4)\n\nReturns a 'nx1' dimensional array of Running Maximum process.\n\n\n\n\n\n","category":"function"},{"location":"#ScenTrees2.sample_path-Union{Tuple{Tree{A, B, C, D}}, Tuple{D}, Tuple{C}, Tuple{B}, Tuple{A}, Tuple{Tree{A, B, C, D}, Any}, Tuple{Tree{A, B, C, D}, Any, Any}, Tuple{Tree{A, B, C, D}, Any, Any, Any}} where {A, B, C, D}","page":"Home","title":"ScenTrees2.sample_path","text":"sample_path(trr::Tree,nPath=1, flag_show=true)\n\nPlots nPath sample paths of the tree trr weighted by the probability of the path occuring.  TODO: plot whole tree, make opaque and only sample paths are dark\n\n\n\n\n\n","category":"method"},{"location":"#ScenTrees2.stage-Union{Tuple{Tree{A, B, C, D}}, Tuple{D}, Tuple{C}, Tuple{B}, Tuple{A}, Tuple{Tree{A, B, C, D}, Any}} where {A, B, C, D}","page":"Home","title":"ScenTrees2.stage","text":"stage(trr::Tree, node=Int64[])\n\nReturns the stage of each node in the tree.\n\nArguments:\n\ntrr - an instance of a Tree.\nnode - the number of node in the scenario tree you want to know its stage.\n\n\n\n\n\n","category":"method"},{"location":"#ScenTrees2.structure-Tuple{Lattice}","page":"Home","title":"ScenTrees2.structure","text":"structure(lat::Lattice)\n\nProvides a summary on the branching structure of the lattice lat.\n\nValues\n\nbs: vector indicating the number of nodes in each stage, i.e. the branching structure.\nnodes: the total number of nodes.\nedges: the total number of edges.\npaths: the total number of unique paths.\n\nExample\n\njulia> lat = Lattice(304);\njulia> structure(lat)\n([1, 2, 3, 4], 10, 20, 24)\n\n\n\n\n\n","category":"method"},{"location":"#ScenTrees2.tree_approximation!-Union{Tuple{D}, Tuple{C}, Tuple{B}, Tuple{A}, Tuple{Tree{A, B, C, D}, Function, Int64}, Tuple{Tree{A, B, C, D}, Function, Int64, Int64}, Tuple{Tree{A, B, C, D}, Function, Int64, Int64, Int64}} where {A, B, C, D}","page":"Home","title":"ScenTrees2.tree_approximation!","text":"tree_approximation!(newtree::Tree, path::Function, nIterations::Int64, p::Int64=2, r::Int64=2)\n\nReturns a valuated probability scenario tree approximating the input stochastic process.\n\nArgs:\n\nnewtree - Tree with a certain branching structure,\npath - function generating samples from the stochastic process to be approximated,\nnIterations - number of iterations for stochastic approximation procedure,\np - choice of norm (default p = 2 (Euclidean distance)), and,\nr - transportation distance parameter\n\n\n\n\n\n","category":"method"}]
}
